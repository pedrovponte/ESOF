[Link to test](https://drive.google.com/drive/u/0/folders/1bZAFZsWGN6cseigeaaXAS9GwVvA1kb_1)

## Resolução

**1.** a) software is mainly made up of abstractions, written in concrete languages

**Justificação:** SOmetimes it's hard to understand what the other has done, due to how abstract it sometimes is.

**2.** b) Elaboration

**Justificação:** During this phase, the problem domain is analysed and it's defined a stable and robust architecture for all system, taking in count its requisites. While analyzing, the main result is the analyse model (classes and ideal collaborations), and in design the main result is the project model (implementation classes grouped by sub-systems, necessary collaborations to realize the use cases) and the distribution model.

**5.** c) Requirements engineering is very valued in waterfall-like processes, being always the first phase of the development process. More recent processes assume the importance of requirements engineering along all the process, even at usability studies phases.

**Justificação:** Requirements are one of the most important aspects of a project as they describe what the system should (not) do. Therefore it is important they are well defined, complete and consistent, hence a discipline dedicated to it and different kinds of requirements defined (as stated in b), however non-functional might be more critical since that if they fail, the whole system may not work. Agile projects consider the importance of requirements along all the process and, in the modern days, requirements are in constant change and the project (and its team) must adapt frequently to (sometimes drastic) changes.

**6.** d) Object level

**Justificação:** Here we are using functionalities already developed and compiled into a library (here stdio.h) that allow us, in this case, to write a message to the screen. If we were to do this ourselves, from scratch, the code would have been much bigger.

**7.** c) The existing development documentation

**Justificação:** Since projects tend to be developed using methodologies such as agile methods, that tend to minimize documentation, so it gets harder to understand how the software is organized and structured, making it harder to evolve.

**9.** d) to recognize and positively discriminate individuals based on their individual performance.

**Justificação:** Recognize individual work tends to make each developer to work alone ("Heroic development"), which makes the projects depending on each member performance, growing up the number of errors on project.

**10.** In order to find the best way to implement a correction, it is essential that the project owner has a good documentation, so the contributors can easily know how to run the project, test and how it was done. After knowing all this, is is necessary to study the problem and try to find the problem source. Finally, after find the lines that have errors, the developers have to try different solutions until they can fix the bug.