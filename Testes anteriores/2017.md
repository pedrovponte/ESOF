[Link to test](https://drive.google.com/drive/u/0/folders/1zmCkIqMYYK1JVbTNMjQMvJDOHtCrQmW1)

## Resolução

**1.** b) In the late 60's, to address the growing importance of software

**Justificação:** Software was becoming a more and more important tool. However, it didn't have a proper set of "rules" or good practices that could be applied and software development was a very complicated process, which led to a lot of problems during development, resulting in a lot of money lost. All this led to the famous NATO conference to establish software engineering, where the term was first used and defined.

**2.** b) Elaboration

**Justificação:** It is in the elaboration phase that requirements are stabilized and a base architecture is built around and ensure all requirements will be met. This base architecture is described through several diagrams, covering object organization (UML Class Diagram), use cases (simple diagrams with Actors), more detailed functionalities through UML Sequence or State Diagrams. There is usually a Designer responsible for the conception of the diagrams, whereas an Architect will be responsible for most of its documentation, if the case.

**3.** c) Pair programming, refactoring, test first

**Justificação:** Pair programming is the activity where two programmers work together at one machine. While one enters the code, the other evaluate the code and critiques it.
Refactoring is the process that allows programmers to improve the structure of the code without changing externally visible behavior (eg: removing duplicated code).
Test first (Test Driven Development) is a way of development where the unit tests are written first and only then the necessary code to pass it is developed.

**4.** c) Effort estimations and previous sprint velocity can be used to extrapolate when the backlog will be complete

**Justificação:** In each sprint the team's effort and velocity is measured to provide an important progress measurement tool in planning the next sprint. With this, the team can have a better understanding of how they progress and make requirements prioritization that will suit them best, ensuring a better chance of the necessary deadlines.

**5.** c) Requirements engineering is very valued in waterfall-like processes, being always the first phase of the development process. More recent processes assume the importance of requirements engineering along all the process, even at usability studies phases

**Justificação:** Requirements are one of the most important aspects of a project as they describe what the system should (not) do. Therefore it is important they are well defined, complete and consistent, hence a discipline dedicated to it and different kinds of requirements defined (as stated in b), however non-functional might be more critical since that if they fail, the whole system may not work. Agile projects consider the importance of requirements along all the process and, in the modern days, requirements are in constant change and the project (and its team) must adapt frequently to (sometimes drastic) changes.

**6.** d) Object level

**Justificação:** Here we are using functionalities already developed and compiled into a library (here stdio.h) that allow us, in this case, to write a message to the screen. If we were to do this ourselves, from scratch, the code would have been much bigger.

**7.** c) As software ages and becomes "legacy", if maintaining the system remains feasible and cost-effective.

**Justificação:** Maintenance is an important aspect in software development as maintaining software can be even more expensive than developing new software. Therefore, maintenance and change prediction are important tools to determine if a given software, as it ages, is worth maintaining or should just be totally replaced.

**8.** a) "Test-first" and refactoring

**Justificação:** The test-first methodology helps ensure the developer will create only the necessary code to pass the tests. This way, there's a smaller chance the programmer will make unnecessary code and, thus, make a larger codebase. With this in mind, at each new test the code addiction should be minimal, so refactoring is encouraged as a way to, at each step, review what has been done and possibly restructure in a better way according to well known refactor techniques, contributing again to a smaller and more balanced codebase.

**9.** b) the developers estimate the time to implement a set of features.

**Justificação:** By doing that, the manager can more accurately estimate the required time for the next release and plan out with the team the feasibility of said features.
